# Jitsi Meet + Docker + Tailscale no Void Linux
## Final, Revised and Correct Guide (root)

This tutorial covers **everything** that was done, including:
- installing the right packages
- activation of services in Void (runit)
- clone da stack docker-jitsi-meet
- port mapping fix (127.0.0.1)
- .env tweak
- docker-compose.yml tweak
- port 80 issues with native nginx
- Tailnet limitations (without Funnel)
- solution via Tailscale Serve (internal)
- final access via `https://jitsi.tailf0138e.ts.net`
- no fixed IP, no opening ports, no external DNS

---

## 1. Install required packages

```bash
xbps-install -Sy docker docker-compose tailscale git
```

Enable Void services:

```bash
ln -s /etc/sv/docker /var/service/
ln -s /etc/sv/tailscaled /var/service/
sv status docker tailscaled
```

---

## 2. Activate and authenticate Tailscale

```bash
tailscale up
```

Open link in browser, log in, authorize.

Rename the device within Tailnet:

```bash
tailscale set --hostname=jitsi
```

Confirm DNSName:

```bash
tailscale status --json | grep DNSName
```

Expected:

```
"DNSName": "jitsi.tailf0138e.ts.net.",
```

‚ö† Important:
- If you are NOT a Tailnet admin
- Therefore **Funnel is blocked**
- But Internal Serve works perfectly

---

## 3. Download and prepare the Jitsi stack

```bash
mkdir -p /opt/jitsi
cd /opt/jitsi
git clone https://github.com/jitsi/docker-jitsi-meet.git
cd docker-jitsi-meet
cp env.example .env
./gen-passwords.sh
```

---

## 4. Adjust `.env` for use with Tailscale
(first we need to confirm Tailnet's IP and internal DNS)

Before editing `.env`, confirm:

**1 ‚Äî Tailscale internal IP**

```bash
tailscale ip -4
```

Actual example used:
```
100.75.137.60
```

**2 ‚Äî Internal DNS name of the machine on Tailnet**

```bash
tailscale status --json | grep DNSName
```

Actual result:

```
"DNSName": "jitsi.tailf0138e.ts.net.",
```

This is the **true internal** domain generated by Tailscale, based on the configured hostname and Tailnet ID.

Only after that edit the `.env`:

```bash
nano /opt/jitsi/docker-jitsi-meet/.env
```

Configure it like this:

```ini
PUBLIC_URL=https://jitsi.tailf0138e.ts.net
ENABLE_LETSENCRYPT=0
DISABLE_HTTPS=1
ENABLE_AUTH=1
ENABLE_GUESTS=1
AUTH_TYPE=internal

XMPP_DOMAIN=meet.jitsi
#XMPP_AUTH_DOMAIN=auth.meet.jitsi
#XMPP_AUTH_DOMAIN_PREFIX=auth
XMPP_MUC_DOMAIN=muc.meet.jitsi
XMPP_INTERNAL_MUC_DOMAIN=internal-muc.meet.jitsi
XMPP_GUEST_DOMAIN=guest.meet.jitsi




```

### Justifications:
- **PUBLIC_URL points to Tailscale's internal name**
as it is the actual URL used to access the server within Tailnet.

- **HTTPS inside the container is disabled because TLS comes from Tailscale**
(Tailscale Serve provides built-in HTTPS and we don't need Jitsi's nginx TLS).

- **We do not use Let‚Äôs Encrypt because there is no public domain or Funnel released**
and the TailNet Admin has not yet enabled the feature, so public TLS does not exist ‚Äî only internal.

---

## 5. Adjust docker-compose.yml
(very important ‚Äî this is where we fixed the biggest headache)

This step is absolutely ESSENTIAL because this is where we corrected:

- Void's nginx appearing in Jitsi's place
- 80/8000 port conflict
- Tailscale Serve complaining that ‚Äúonly localhost is supported‚Äù
- Jitsi being served externally unintentionally
- backend not working on Serve
- the need to expose local-only
- automatic container startup
- preparation for future FUNNEL without changing anything afterwards

The `web` service must ONLY expose on localhost, because:

- **Tailscale Serve REQUIRES backend on 127.0.0.1**
(current version of Serve only accepts localhost, otherwise it gives a proxy error)
- **Avoids conflict with Void's nginx**, which runs on system port 80
(that's why it said ‚ÄúWelcome to nginx!‚Äù)
- **Ensures that Serve routes to Jitsi**, not the host's nginx
- **Prevents accidental exposure on the internet**, as localhost does not accept external connections
- **Guarantees future compatibility with FUNNEL**, if the TailNet Admin releases
- **With `restart: always`, containers start automatically after reboot**, without additional runit

Edit the compose:

```bash
nano /opt/jitsi/docker-jitsi-meet/docker-compose.yml
```

And leave it EXACTLY like this:

```yaml
services:

  web:
    image: jitsi/web:unstable
    restart: always
    ports:
      - "127.0.0.1:8000:80"
      - "127.0.0.1:8443:443"

  prosody:
    image: jitsi/prosody:unstable
    restart: always

  jicofo:
    image: jitsi/jicofo:unstable
    restart: always

  jvb:
    image: jitsi/jvb:unstable
    restart: always
```

Brief explanation:

- **127.0.0.1:8000 ‚Üí 80**
‚Üí Port 80 of the container only exists internally, and the recipient is 127.0.0.1
‚Üí That‚Äôs why Tailscale Serve can redirect correctly

- **restart: always**
‚Üí If Void restarts, Jitsi comes back alone
‚Üí If Docker restarts, Jitsi comes back by itself
‚Üí If there is a power outage, it returns alone

- **This 100% eliminates the Void nginx issue**
- **This makes Jitsi invisible on the public internet** (which is desired within Tailnet)
- **This sets everything up to activate Funnel in the future with just one command**

Save and exit.

---

## 6. Upload the Docker stack

```bash
docker-compose up -d
docker-compose ps
```

Confirm that the web is **127.0.0.1:8000 ‚Üí 80**.

Test the frontend within the server:

```bash
curl -I http://127.0.0.1:8000
```

Expected:

```
HTTP/1.1 200 OK
Server: nginx
```

‚ö† If you saw "Welcome to nginx!", it was Void's nginx.
This test ensured that the Jitsi backend is correct.

---

## 7. Expose via Tailscale Serve (internal)

Reset any previous rules:

```bash
tailscale serve reset
```

Create the internal proxy:

```bash
tailscale serve --bg http://127.0.0.1:8000
```

Expected output:

```
Available within your tailnet:

https://jitsi.tailf0138e.ts.net/
|-- proxy http://127.0.0.1:8000
```

Check status:

```bash
tailscale serve status
```

Tailscale Serve is now correctly serving Jitsi.

---

## 8. Access via Tailnet (works on ANY network)

On your laptop, cell phone, PC ‚Äî as long as you are logged in to Tailscale:

```
https://jitsi.tailf0138e.ts.net/
```

Yes:

- HTTPS works
- Tailscale certificate is valid
- No warning
- No Void nginx
- No :8000
- Everything directly in the beautiful domain

‚ö† Access **only** for Tailnet members (for now).

---

## 9. Useful commands

Ver containers:

```bash
docker-compose ps
```

Logs:

```bash
docker-compose logs -f web
```

To stop:

```bash
docker-compose down
```

Serve status:

```bash
tailscale serve status
```

Reset serve:

```bash
tailscale serve reset
```

---

## 10. Adding users

```bash
docker compose exec prosody prosodyctl --config /config/prosody.cfg.lua register admin meet.jitsi Jitsi1234
```

Expected output:

```
usermanager         info	User account created: admin@meet.jitsi
```

---

## 11. When the TailNet Admin releases FUNNEL (optional, public access)

If the **TailNet Admin** enables Funnel, you will be able to expose
Jitsi for the entire INTERNET, with valid HTTPS, without depending on a firewall, modem or fixed IP.

With Funnel activated, you perform:

```bash
tailscale funnel --https=443 http://127.0.0.1:8000
```

And the access becomes:

```
https://jitsi.tailf0138e.ts.net/
```

---

### üî∂ IMPORTANT NOTE: HOW TO RELEASE FUNNEL

Only the **TailNet administrator** can enable Funnel.

The Admin needs to do:

1. Enter:
https://login.tailscale.com/admin/acls

2. In the side menu, click on:
   **Settings ‚Üí Funnel**

3. Activate the option:
‚úî **Allow Funnel for this tailnet**

4. And also activate:
‚úî select **jitsi** device
(or the name you set with `tailscale set --hostname`)

5. Save.

After that, you test:

```bash
tailscale funnel status
```

If it is enabled, the command stops giving an error and you can activate Funnel normally.

---

### ‚úî What changes when Funnel is active

- Jitsi is PUBLICLY accessible (without TailNet)
- Automatically valid HTTPS (via Tailscale's Let's Encrypt)
- The URL remains:
  ```
  https://jitsi.tailf0138e.ts.net/
  ```
- Can be shared with ANYONE

---

### ‚úî What DOES NOT change

- Nothing from the previous tutorial breaks
- Internal service continues to work
- Docker does not need to be modified
- Jitsi doesn't need to restart

---

## END
Revised configuration, clean, no holes.
Everything in good order and working.
